<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAAR - Local Summarization</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font family -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        /* CSS from style.css integrated here */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; 
        }
        .text-gradient {
            background-image: linear-gradient(45deg, #10b981, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .main-card {
            background-color: #161b22; 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        /* Custom scrollbar for the textarea and results panel */
        textarea::-webkit-scrollbar, .result-panel::-webkit-scrollbar {
            width: 6px;
        }
        textarea::-webkit-scrollbar-thumb, .result-panel::-webkit-scrollbar-thumb {
            background-color: #06b6d4;
            border-radius: 3px;
        }
        /* Keyframe animation and styling for the loading spinner */
        .loading-spinner {
            border-top-color: #06b6d4;
            border-left-color: #06b6d4;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="min-h-screen text-white">

    <!-- Header / Navigation (Simplified) -->
    <header class="bg-gray-900 border-b border-gray-700/50 p-4">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <a href="#" class="text-2xl font-extrabold text-gradient">SAAR (Local)</a>
            <span class="text-sm text-gray-500">Connecting to Python Backend on localhost:5000</span>
        </div>
    </header>

    <!-- Main Application Container -->
    <main class="max-w-7xl mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-6xl font-extrabold mb-3 leading-tight">
                Get the <span class="text-gradient">Conciseness You Need</span>
            </h1>
            <p class="text-gray-400 text-lg md:text-xl">Instantly summarize text using your local Gemini API proxy.</p>
        </header>

        <!-- Main Input and Output Area -->
        <div class="flex flex-col lg:flex-row gap-8">
            
            <!-- Left Panel: Input & Controls -->
            <div class="lg:w-1/2 w-full main-card p-6 rounded-xl">
                <h2 class="text-2xl font-bold mb-4">Paste Text</h2>
                
                <textarea id="source-text" rows="15" placeholder="Paste your text here (up to 5000 characters)..." 
                          class="w-full p-4 rounded-lg border border-gray-700 bg-gray-800 text-white focus:ring-cyan-500 focus:border-cyan-500 transition resize-none"></textarea>
                
                <div class="flex justify-center mt-4">
                    <button id="summarize-button" class="w-full sm:w-auto bg-cyan-500 hover:bg-cyan-600 text-gray-900 font-bold py-3 px-8 rounded-xl transition duration-300 ease-in-out transform hover:scale-[1.02] flex items-center justify-center disabled:opacity-50" disabled>
                        <i data-lucide="zap" class="w-5 h-5 mr-2"></i>
                        Summarize & Analyze
                    </button>
                </div>
                
                <p class="text-sm text-gray-500 mt-2 text-right">Character Count: <span id="char-count">0</span> / 5000</p>
                <div id="status-message" class="mt-4 p-3 rounded-lg text-sm text-center bg-transparent"></div>
            </div>

            <!-- Right Panel: Results & Stats -->
            <div class="lg:w-1/2 w-full main-card p-6 rounded-xl flex flex-col">
                <h2 class="text-2xl font-bold mb-4">Summary & Revision Notes</h2>
                
                <div class="flex justify-between items-center mb-4 text-sm text-gray-400">
                    <div id="reading-time-container" class="flex items-center space-x-4">
                        <span class="flex items-center"><i data-lucide="clock" class="w-4 h-4 mr-1"></i> Read Time: <span id="reading-time" class="ml-1 text-teal-400 font-semibold">--</span></span>
                        <span class="flex items-center"><i data-lucide="list" class="w-4 h-4 mr-1"></i> Length: <span id="summary-length" class="ml-1 text-teal-400 font-semibold">--</span></span>
                    </div>
                    
                    <div class="flex space-x-3">
                        <button id="read-aloud-button" class="p-2 rounded-full bg-gray-700 hover:bg-teal-600 transition disabled:opacity-50" disabled title="Read Aloud Summary">
                            <i data-lucide="volume-2" class="w-5 h-5 text-white"></i>
                        </button>
                        <button id="copy-button" class="p-2 rounded-full bg-gray-700 hover:bg-cyan-600 transition disabled:opacity-50" disabled title="Copy Notes">
                            <i data-lucide="copy" class="w-5 h-5 text-white"></i>
                        </button>
                    </div>
                </div>

                <div class="mb-4">
                    <label for="summary-option" class="block text-sm font-medium text-gray-400 mb-1">Summary Length Option:</label>
                    <select id="summary-option" class="w-full p-2 rounded-lg border border-gray-700 bg-gray-800 text-white focus:ring-cyan-500 focus:border-cyan-500 transition">
                        <option value="concise">Concise (5 Bullet Points)</option>
                        <option value="detailed">Detailed (10 Bullet Points)</option>
                        <option value="keywords">Keywords Only</option>
                    </select>
                </div>

                <div id="summary-output" class="result-panel flex-grow p-4 rounded-lg border border-gray-700 bg-gray-800 overflow-y-auto min-h-[300px] text-gray-300 leading-relaxed space-y-3">
                    <p class="text-gray-500 italic">Your summarized and analyzed notes will appear here. The keywords will be automatically <span class="text-yellow-400 font-semibold">highlighted</span>. Ensure your Python backend is running!</p>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="mt-16 p-6 border-t border-gray-700/50 text-center text-gray-500">
        <p>&copy; 2025 SAAR - Local Version. Powered by Gemini API via Python Flask server.</p>
    </footer>
    
    <script>
        // --- DOM ELEMENT CACHING & UTILITIES ---
        const sourceTextEl = document.getElementById('source-text');
        const summarizeButton = document.getElementById('summarize-button');
        const charCountEl = document.getElementById('char-count');
        const statusMessageEl = document.getElementById('status-message');
        const summaryOutputEl = document.getElementById('summary-output');
        const readAloudButton = document.getElementById('read-aloud-button');
        const copyButton = document.getElementById('copy-button');
        const readingTimeEl = document.getElementById('reading-time');
        const summaryLengthEl = document.getElementById('summary-length');

        // --- Utility Functions ---

        // Exponential backoff retry utility for API calls
        async function fetchWithRetry(url, options, maxRetries = 5) {
            let delay = 1000;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429 && i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                        continue;
                    }
                    if (!response.ok) {
                        const errorBody = await response.json(); // Server returns JSON error
                        throw new Error(errorBody.error || `Server call failed with status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    console.warn(`Retry ${i + 1}/${maxRetries} due to error: ${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
        }

        // Show status messages
        function setStatus(message, type = 'info') {
            statusMessageEl.textContent = message;
            statusMessageEl.className = `mt-4 p-3 rounded-lg text-sm text-center`;
            
            const isErrorOrInfo = type === 'error' || type === 'info';

            if (type === 'loading') {
                statusMessageEl.classList.add('bg-gray-800', 'text-cyan-400', 'flex', 'items-center', 'justify-center');
                // Use a standard Tailwind spinner for simplicity in a single file
                statusMessageEl.innerHTML = `<div class="loading-spinner border-4 border-gray-700 border-solid w-5 h-5 rounded-full mr-2"></div> ${message}`;
                summarizeButton.disabled = true;
            } else if (type === 'error') {
                statusMessageEl.classList.add('bg-red-900/50', 'text-red-400');
                summarizeButton.disabled = false;
            } else { // info/success
                statusMessageEl.classList.add('bg-teal-900/50', 'text-teal-400');
                summarizeButton.disabled = false;
            }
            
            // Control other buttons based on state
            if (isErrorOrInfo) {
                const hasContent = summaryOutputEl.textContent.trim() !== '' && !summaryOutputEl.querySelector('.text-red-400');
                readAloudButton.disabled = !hasContent;
                copyButton.disabled = !hasContent;
            } else if (type === 'loading') {
                readAloudButton.disabled = true;
                copyButton.disabled = true;
            }
        }

        // Calculate Reading Time (WPM = 200 words per minute average)
        function calculateReadingTime(text) {
            const wordCount = text.trim().split(/\s+/).length;
            const minutes = Math.ceil(wordCount / 200);
            return `${minutes} min`;
        }

        // Helper to construct the summary prompt
        function createSummaryPrompt(text, option) {
            let instruction = "";
            switch (option) {
                case 'concise':
                    instruction = "Provide a concise summary of the following text, focusing only on the most critical information, in exactly 5 short, clear bullet points. Highlight key terms with <mark> tags:";
                    break;
                case 'detailed':
                    instruction = "Provide a detailed summary of the following text, including supporting concepts, in exactly 10 short, clear bullet points. Highlight key terms with <mark> tags:";
                    break;
                case 'keywords':
                    instruction = "Extract the 15 most important key terms and concepts from the following text and list them as bullet points. Do not include any sentences or descriptive text:";
                    break;
            }
            return `${instruction}\n\nTEXT:\n---\n${text}`;
        }

        // Helper to format the summary (handles markdown list to HTML)
        function formatSummary(text) {
            // Replace markdown bullet points with HTML structure
            let html = text.replace(/^- /gm, '<li>');
            html = html.replace(/\*/gm, ''); // Remove any lingering asterisks
            html = html.replace(/<mark>/g, '<span class="text-yellow-400 font-semibold p-0.5 rounded-sm bg-gray-700/50">');
            html = html.replace(/<\/mark>/g, '</span>');
            
            // Check if it's already a list and wrap if necessary
            if (html.includes('<li>')) {
                return `<ul class="list-disc list-inside space-y-2">${html}</ul>`;
            }
            
            // If it's a paragraph or other format, wrap in <p> (with markups applied)
            return `<p>${html}</p>`;
        }

        // --- TTS Audio Conversion Functions ---

        // Helper function to convert base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Helper function to convert PCM audio data to a WAV Blob (Signed 16-bit PCM)
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcm16.byteLength;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF header
            view.setUint32(0, 0x52494646, false); // "RIFF"
            view.setUint32(4, 36 + dataSize, true); // ChunkSize
            view.setUint32(8, 0x57415645, false); // "WAVE"

            // fmt sub-chunk
            view.setUint32(12, 0x666d7420, false); // "fmt "
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);

            // data sub-chunk
            view.setUint32(36, 0x64617461, false); // "data"
            view.setUint32(40, dataSize, true);

            // Copy the PCM data
            const pcmDataView = new Uint8Array(buffer, 44);
            pcmDataView.set(new Uint8Array(pcm16.buffer));

            return new Blob([buffer], { type: 'audio/wav' });
        }

        // --- EVENT LISTENERS ---

        // Character Count and Summarize Button Enable
        sourceTextEl.addEventListener('input', () => {
            const text = sourceTextEl.value;
            const count = text.length;
            charCountEl.textContent = count;
            
            // Limit to 5000 characters
            if (count > 5000) {
                sourceTextEl.value = text.substring(0, 5000);
                charCountEl.textContent = 5000;
                setStatus("Text limited to 5000 characters.", 'info');
            }

            // Enable summarize button only if text is substantial
            summarizeButton.disabled = count < 50;
        });

        // Copy Summary Button
        copyButton.addEventListener('click', () => {
            const summary = summaryOutputEl.textContent;
            if (summary.trim()) {
                const textarea = document.createElement('textarea');
                textarea.value = summary;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    // document.execCommand('copy') is generally available in browsers
                    document.execCommand('copy');
                    setStatus("Summary copied to clipboard!", 'info');
                } catch (err) {
                    console.error('Could not copy text: ', err);
                    setStatus("Failed to copy summary.", 'error');
                }
                document.body.removeChild(textarea);
            }
        });

        // --- Summarization (Gemini 2.5 Flash) ---
        summarizeButton.addEventListener('click', async () => {
            const sourceText = sourceTextEl.value.trim();
            const summaryOption = document.getElementById('summary-option').value;

            if (sourceText.length < 50) {
                setStatus("Please enter at least 50 characters of text to summarize.", 'error');
                return;
            }
            
            // Set UI to loading state
            setStatus("Analyzing and summarizing text...", 'loading');
            summaryOutputEl.innerHTML = `<p class="text-gray-500 italic text-center">Working magic...</p>`;
            readingTimeEl.textContent = '--';
            summaryLengthEl.textContent = '--';

            const summaryPrompt = createSummaryPrompt(sourceText, summaryOption);
            
            // Fetch to the Python backend's summarize endpoint
            try {
                const response = await fetchWithRetry('/summarize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ summaryPrompt }) // Send prompt to backend
                });
                
                const result = await response.json();
                const textResult = result.summary || "Error: Could not generate summary.";

                // 1. Process and display summary
                const formattedSummary = formatSummary(textResult);
                summaryOutputEl.innerHTML = formattedSummary;
                
                // 2. Update stats
                readingTimeEl.textContent = calculateReadingTime(summaryOutputEl.textContent);
                summaryLengthEl.textContent = `${summaryOutputEl.textContent.split(/\s+/).length} words`;
                
                setStatus("Summarization complete!", 'info');

            } catch (error) {
                console.error("Server/API Error:", error);
                summaryOutputEl.innerHTML = `<p class="text-red-400">An error occurred during summarization: ${error.message}. Ensure your Python server is running and the API Key is set correctly.</p>`;
                setStatus(`Error: ${error.message}`, 'error');
            }
        });


        // --- Text-to-Speech (TTS) ---
        readAloudButton.addEventListener('click', async () => {
            const textToSpeak = summaryOutputEl.textContent.trim();
            if (!textToSpeak || summaryOutputEl.querySelector('.text-red-400')) {
                setStatus("Nothing valid to read aloud.", 'error');
                return;
            }

            const previousIcon = readAloudButton.querySelector('i').outerHTML;
            readAloudButton.innerHTML = `<i data-lucide="loader-2" class="w-5 h-5 text-white animate-spin"></i>`;
            readAloudButton.disabled = true;
            
            setStatus("Generating and playing audio...", 'loading');

            // Fetch to the Python backend's read-aloud endpoint
            try {
                const response = await fetchWithRetry('/read-aloud', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ textToSpeak }) // Send text to backend
                });
                
                const result = await response.json();
                const audioData = result.audioData;
                const mimeType = result.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    // API returns signed PCM16 audio data at a fixed sample rate (usually 24000)
                    const sampleRate = 24000; 
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    
                    // Convert PCM data to a playable WAV Blob
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    // Play the audio
                    const audio = new Audio(audioUrl);
                    audio.play();

                    setStatus("Audio playing...", 'info');

                    // Wait for audio to finish before re-enabling controls
                    audio.onended = () => {
                        setStatus("Read aloud finished.", 'info');
                        readAloudButton.innerHTML = previousIcon;
                        readAloudButton.disabled = false;
                    };

                    audio.onerror = (e) => {
                        console.error("Audio playback error:", e);
                        setStatus("Error playing audio.", 'error');
                        readAloudButton.innerHTML = previousIcon;
                    };

                } else {
                    throw new Error("Invalid audio data or mime type received from server.");
                }

            } catch (error) {
                console.error("TTS Server/API Error:", error);
                setStatus(`TTS Error: ${error.message}`, 'error');
            } finally {
                // Revert button icon if still in loading state
                if (readAloudButton.querySelector('.animate-spin')) {
                    readAloudButton.innerHTML = previousIcon;
                }
            }
        });
        
        // This ensures Lucide icons are correctly rendered after the script runs
        document.addEventListener('DOMContentLoaded', (event) => {
            lucide.createIcons();
        });
    </script>
</body>
</html>